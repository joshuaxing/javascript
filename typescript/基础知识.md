## 基础类型-1

#### 布尔值|数字|字符串|数组

```
let isDone: boolean = false
let count: number = 6
let name: string = "bob"
let list: number[] = [1, 2, 3]
let list: Array<number> = [1, 2, 3]
```

#### 元组 Tuple 数量和类型已知的数组

```
let student: [string, number] = ['xiaoxing', 10]
```

#### 普通枚举

类型是对 JavaScript 标准数据类型的一个补充

```
enum Gender {
  BOY,
  GIRL
}
console.log(Gender['BOY'], Gender[1]) // 0 , BOY

// 编译成js

var Gender;
(function (Gender) {
  Gender[Gender["BOY"] = 0] = "BOY";
  Gender[Gender["GIRL"] = 1] = "GIRL";
})(Gender || (Gender = {}));
console.log(Gender['BOY']);
```

### 常量枚举

```
const enum Colors {
  Red,
  Green,
  Blue
}
let myColor = [Colors.Red, Colors.Green, Colors.Blue];
```

#### any 任意类型

可以赋值给任意类型，不进行类型检查

```
let root:any = document.getElementById('root')
root.style.color = 'red'

// 如果strictNullChecks的值为true
let element: (HTMLElement | null) = document.getElementById('root')
// 非空断言
element!.style.color = 'green'

```

#### null undefined

可以是其他类型的子类型

```
// 如果strictNullChecks的值为true, 则不能把null undefined 赋值给 x
let x: number
x = 1;
x = undefined;
x = null

let y: number | null | undefined
y = 1;
y = undefined;
y = null

```

#### never 代表不会出现的值

```
// 作为不会返回的函数的返回值 类型
function error(msg:string): never {
  thow new Error('报错了')
  console.log('ok')
}
// 死循环
function loop(): never {
  while (true) {}
  console.log('ok')
}
// 类型保护
function fn(x: number | string) {
  if (typeof x === 'number') {
      console.log(x.toFixed(2))
  } else if (typeof x === 'string') {
      console.log(x.charAt(0))
  } else {
      console.log(x) // never
  }
}
```
#### void 代表没有任何类型
// 函数没有返回值，那么就是void类型
// void可以被undefined赋值
// strictNullChecks=false void可以被null赋值
```
function greeting():void {
  return undefined
}
```

#### void 和 never 的区别
1. void可以被undefined，null赋值， never不能包括任何类型
2. 返回类型为void的函数还能执行，但是返回never的函数无法正常执行


#### Symbol ES6
// "lib": ["ESNext"]
```
const s1 = Symbol('key')
const s2  = Symbol('key')
console.log(s1 === s2)
```

#### BigInt
js里的类型 Number BigInt
ts里的类型 number bigint

// "lib": ["ESNext"]
```
// const max = Number.MAX_SAFE_INTEGER // 2**53-1
// console.log(max+1 === max +2 ) // true

const max = BigInt(Number.MAX_SAFE_INTEGER) 
// console.log(max+1  === max+2 ) 
console.log(max+BigInt(1) === max+BigInt(2)) // false
// "target": "ESNext"
console.log(max+1n === max+2n) // false

```

#### 类型推导
```
let str = 'ddddd'
```

#### 包装对象 wrapper
```
let title = 'zhufeng'
console.log(title.toUpperCase())
// 内部会自动包装成对象类型
console.log(new String(title).toUpperCase())

let isOk1: boolean = true
let isOk2: boolean = Boolean(1)
// 不能把对象类型赋值给基本类型
// let isOk3: boolean = new Boolean(1) // 报错

```

#### 联合类型
没有赋值之前只能调用共同的方法
赋值之后可以调用赋值类型的方法
```
let name3: string | number
console.log(name3!.toString())
name3 = 3;
console.log(name3.toFixed(2))
name3 = 'zhufeng'
console.log(name3!.length)

```
#### 类型断言
```
let name4: string | number;
console.log((name4! as number).toFixed(2))
console.log((name4! as string).length)
// 双重断言
console.log((name4! as any as boolean))
```

#### 字符串字面量类型
可以实现枚举的效果
```
const up: "Up" = "Up";
const down: "Down" = "Down";
type Direction = "Up" | "Down";
function move(direction: Direction) {

}
move("Down");
```

#### 类型字面量
```
type Person = {
  name: string;
  age: number;
};
let p: Person = {
  name: "zhufeng",
  age: 10,
};
```

#### 字符串字面量 vs 联合类型
字符串字面量只能是定义的值，联合类型可是多个类型
```
type T1 = '1' | 2 | '3';
let t1:T1  = '1';

type T2 = string | number | boolean;
let t2:T2  = true;
```

## 函数-2

#### 函数重载

```
function add(a:string,b:string): void
function add(a:number,b:number): void
function add(a: string | number, b: string | number):void {}
add(1,2)
add('xiao','xing')
// add(1,'xing')
```








### 枚举 enum

- 数字枚举
- 字符串枚举
- 异构枚举 Heterogeneous enums
- 反向映射
- const 枚举
- 外部枚举 declare

### 类型推论

- 按上下文归类

### 模块

### [TypeScript 中提升幸福感的 10 个高级技巧](https://segmentfault.com/a/1190000039030887)

### Typescript 中的 interface 和 type

- 相同点

  ```
    interface Name {
      name: string
    }

    interface User extends Name {
      age: number
    }

    interface SetUser {
      (name: string, age: number): void;
    }

    type Name {
      name: string
    }

    type User = Name & (age: number)

    type SetUser = (name: string, age: number) : void

  ```

- 不同点-

  ```
  // 可以声明基本类型别名，联合类型，元组等类型
    type Name = string
    interface Dog {
     wong();
    }
    interface Cat {
      miao();
    }
    type Pet = Dog | Cat
    type PetList = [Dog, Pet]
  // 当你想获取一个变量的类型时，使用 typeof
    let div = document.createElement('div');
    type B = typeof div
  // 其他骚操作
    type StringOrNumber = string | number;
    type Text = string | { text: string };
    type NameLookup = Dictionary<string, Person>;
    type Callback<T> = (data: T) => void;
    type Pair<T> = [T, T];
    type Coordinates = Pair<number>;
    type Tree<T> = T | { left: Tree<T>, right: Tree<T> };
  ```

### 深入理解 TypeScript

https://jkchao.github.io/typescript-book-chinese/#why

### TS 入门

https://ts.xcatliu.com/
