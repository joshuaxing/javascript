## 基础类型-1
#### 布尔值|数字|字符串|数组｜元组 Tuple
```
let isDone: boolean = false
let count: number = 6
let name: string = "bob"
let list: number[] = [1, 2, 3]
let list: Array<number> = [1, 2, 3]
let student: [string, number] = ['xiaoxing', 10]
```
#### 枚举enum
类型是对JavaScript标准数据类型的一个补充
```
enum Color {
  Red, 
  Green, 
  Blue
}
let c: Color = Color.Green;
```
#### any 任意类型
#### null undefined 
可以是其他类型的子类型
### never
#### Symbol
#### BigInt

## 函数-2
#### 函数重载
```
function add(a:string,b:string): void
function add(a:number,b:number): void
function add(a: string | number, b: string | number):void {}
add(1,2)
add('xiao','xing')
// add(1,'xing')
```

## 类-3
#### 存取器 set get
#### 修饰符
public 父类、子类、实例都可以访问
protected  父类、子类可以访问，实例不能访问
private 父类可以访问，子类、实例不能访问
readonly 只读
#### static静态属性
父类、子类、实例都可以访问
子类会覆盖父类的静态方法
#### 抽象类 abstract
一般不会直接被实例化
抽象类中的抽象方法不包含具体实现并且必须在子类中实现
#### 重写 override 
子类重写继承自父类的方法
#### 继承 extends
#### 多态 
同一个方法不同的子类有不同的方法


## 装饰器-4
#### 执行顺序
先上后下 先内后外


## 接口-5
interface 仅定义结构，不需要实现
implements

## 泛型-6


### 枚举 enum

- 数字枚举
- 字符串枚举
- 异构枚举 Heterogeneous enums
- 反向映射
- const枚举
- 外部枚举 declare

### 类型推论
- 按上下文归类

### 模块





### [TypeScript 中提升幸福感的 10 个高级技巧](https://segmentfault.com/a/1190000039030887)


### Typescript 中的 interface 和 type

- 相同点
  ```
    interface Name {
      name: string
    }

    interface User extends Name {
      age: number
    }

    interface SetUser {
      (name: string, age: number): void;
    }

    type Name {
      name: string
    }

    type User = Name & (age: number)

    type SetUser = (name: string, age: number) : void

  ```

- 不同点-

  ```
  // 可以声明基本类型别名，联合类型，元组等类型
    type Name = string
    interface Dog {
     wong();
    }
    interface Cat {
      miao();
    }
    type Pet = Dog | Cat
    type PetList = [Dog, Pet]
  // 当你想获取一个变量的类型时，使用 typeof
    let div = document.createElement('div');
    type B = typeof div
  // 其他骚操作
    type StringOrNumber = string | number; 
    type Text = string | { text: string }; 
    type NameLookup = Dictionary<string, Person>; 
    type Callback<T> = (data: T) => void; 
    type Pair<T> = [T, T]; 
    type Coordinates = Pair<number>; 
    type Tree<T> = T | { left: Tree<T>, right: Tree<T> };
  ```
